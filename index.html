<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture AR Shooter</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1646424915/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1646424915/camera_utils.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #video-container { position: absolute; width: 100%; height: 100%; transform: scaleX(-1); }
        canvas#game-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); color: white; display: flex;
            flex-direction: column; align-items: center; justify-content: center; z-index: 100;
        }
        #ui { position: absolute; top: 20px; left: 20px; color: white; z-index: 20; font-size: 24px; pointer-events: none; }
        .loader { border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 2s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <div class="loader"></div>
        <div id="status">Initializing AI Models...</div>
    </div>

    <div id="ui">Score: <span id="score">0</span></div>
    <video id="input-video" style="display:none"></video>
    <canvas id="game-canvas"></canvas>

<script>
/** * CONFIG & STATE 
 */
const CONFIG = {
    targetCount: 4,
    spawnRadius: 15,
    aimAssistRadius: 1.5,
    gestureThreshold: 0.05, // Distance between thumb and index to fire
    modelDelay: 2 // Detect every N frames to save CPU
};

let score = 0;
let isLoaded = false;
let canFire = true;
let frameCounter = 0;
const targets = [];
const vfxs = [];

/**
 * THREE.JS SETUP
 */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('game-canvas'), alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);

const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(0, 10, 10);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// Laser Line
const laserMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
const laserGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-10)]);
const laserLine = new THREE.Line(laserGeometry, laserMaterial);
scene.add(laserLine);

/**
 * GAME OBJECTS
 */
function createTarget() {
    const geometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
    const material = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x444400 });
    const disc = new THREE.Mesh(geometry, material);
    
    // Spawn at edges
    const angle = Math.random() * Math.PI * 2;
    disc.position.set(Math.cos(angle) * CONFIG.spawnRadius, Math.sin(angle) * CONFIG.spawnRadius, -10);
    disc.rotation.x = Math.PI / 2;
    
    // Velocity toward center
    disc.userData.velocity = new THREE.Vector3().copy(disc.position).multiplyScalar(-0.005);
    scene.add(disc);
    targets.push(disc);
}

function spawnFloatingText(text, pos, color) {
    // Simplified VFX using basic spheres that vanish
    const geometry = new THREE.SphereGeometry(0.1, 8, 8);
    const material = new THREE.MeshBasicMaterial({ color: color });
    const p = new THREE.Mesh(geometry, material);
    p.position.copy(pos);
    p.userData.life = 1.0;
    scene.add(p);
    vfxs.push(p);
}

/**
 * GESTURE RECOGNITION (MediaPipe)
 */
const videoElement = document.getElementById('input-video');
const hands = new Hands({
    locateFile: (file) => `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`
});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.5
});

hands.onResults(onResults);

function onResults(results) {
    try {
        if (!isLoaded) {
            isLoaded = true;
            document.getElementById('loading-overlay').style.display = 'none';
        }

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // "Pistol" Landmarks: Index Tip (8), Thumb Tip (4), Index Base (5)
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];
            
            // Map landmarks to Screen Space
            const x = (0.5 - indexTip.x) * 20; // Inverted for mirror effect
            const y = (0.5 - indexTip.y) * 15;
            
            const aimPos = new THREE.Vector3(x, y, -10);
            let finalTargetPos = aimPos.clone();

            // Magnetic Aim Assist
            let bestTarget = null;
            let minDist = CONFIG.aimAssistRadius;
            
            targets.forEach(t => {
                const d = aimPos.distanceTo(t.position);
                if (d < minDist) {
                    minDist = d;
                    bestTarget = t;
                }
            });

            if (bestTarget) {
                finalTargetPos.copy(bestTarget.position);
                laserLine.material.color.setHex(0x00ff00);
            } else {
                laserLine.material.color.setHex(0xff0000);
            }

            // Update Laser
            laserLine.geometry.setFromPoints([new THREE.Vector3(0, -2, 0), finalTargetPos]);

            // Shooting Logic (Check distance between thumb tip and index base)
            const dist = Math.hypot(thumbTip.x - landmarks[5].x, thumbTip.y - landmarks[5].y);
            
            if (dist < CONFIG.gestureThreshold && canFire) {
                fire(bestTarget, finalTargetPos);
                canFire = false;
                setTimeout(() => { canFire = true; }, 300); // Fire rate limit
            }
        }
    } catch (e) {
        console.error("In-loop crash prevented: ", e);
    }
}

function fire(target, pos) {
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.setValueAtTime(target ? 800 : 200, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.2);

    if (target) {
        score += 10;
        document.getElementById('score').innerText = score;
        spawnFloatingText("HIT", pos, 0x00ff00);
        scene.remove(target);
        targets.splice(targets.indexOf(target), 1);
        createTarget(); // Maintain 4
    } else {
        spawnFloatingText("MISS", pos, 0xff0000);
    }
}

/**
 * MAIN LOOP
 */
const cameraUtils = new Camera(videoElement, {
    onFrame: async () => {
        frameCounter++;
        if (frameCounter % CONFIG.modelDelay === 0) {
            await hands.send({image: videoElement});
        }
    },
    width: 1280,
    height: 720
});
cameraUtils.start();

function animate() {
    requestAnimationFrame(animate);

    // Target movement
    targets.forEach(t => {
        t.position.add(t.userData.velocity);
        t.rotation.z += 0.05;
        // Reset if it flies off center
        if (t.position.length() < 0.5) {
            t.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*20, -10);
        }
    });

    // VFX Cleanup
    for (let i = vfxs.length - 1; i >= 0; i--) {
        vfxs[i].userData.life -= 0.02;
        vfxs[i].position.y += 0.02;
        if (vfxs[i].userData.life <= 0) {
            scene.remove(vfxs[i]);
            vfxs.splice(i, 1);
        }
    }

    renderer.render(scene, camera);
}

// Init Game
for(let i=0; i<CONFIG.targetCount; i++) createTarget();
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
