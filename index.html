<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sodor Island Race</title>
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
        font-family: Arial, sans-serif;
    }
    canvas {
        display: block;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        touch-action: none;
    }
</style>
</head>

<body>
<canvas id="gameCanvas"></canvas>

<script>
/* =========================
   CANVAS & CONTEXT
========================= */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

/* =========================
   GAME STATE
========================= */
let state = 'menu';
let roadOffset = 0;
let startTime = 0;
let lastSpawn = 0;
let spawnInterval = 2.5;
let enemies = [];
let lanes = [];
let roadLeft = 0;
let roadRight = 0;
let player = { x: 0, y: 0, lane: 1 };
let targetX = 0;
let score = 0;
let highScore = parseInt(localStorage.getItem('sodorHS') || '0');
let finalScore = 0;
let scrollVel = 0;
let lastTime = 0;
let keys = {};
let lapLength = 2500;

/* =========================
   AUDIO
========================= */
let audioCtx = null;
let musicOsc = null;
let musicGain = null;
let musicInterval = null;

/* =========================
   CONSTANTS
========================= */
const obsColors = ['#00ff00', '#ffff00', '#00ffff', '#ff00ff', '#ffa500'];
const playerColor = '#ff0000';
const playerDark = '#aa0000';
const carW = 55;
const carH = 75;
const relObsSpeed = 120;

/* =========================
   RESIZE
========================= */
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    lanes[0] = canvas.width * 0.22;
    lanes[1] = canvas.width * 0.5;
    lanes[2] = canvas.width * 0.78;

    roadLeft = lanes[0] - 110;
    roadRight = lanes[2] + 110;

    player.y = canvas.height - 140;
}

/* =========================
   INIT
========================= */
function init() {
    resizeCanvas();
    lastTime = performance.now() / 1000;
    window.addEventListener('resize', resizeCanvas);
    requestAnimationFrame(gameLoop);
}

/* =========================
   MUSIC
========================= */
function startMusic() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (musicOsc) return;

    musicGain = audioCtx.createGain();
    musicGain.gain.value = 0.05;
    musicGain.connect(audioCtx.destination);

    const notes = [110, 147, 165, 196, 220];
    let i = 0;

    musicInterval = setInterval(() => {
        if (musicOsc) musicOsc.stop();

        musicOsc = audioCtx.createOscillator();
        musicOsc.type = 'sawtooth';
        musicOsc.frequency.value = notes[i % notes.length];
        musicOsc.connect(musicGain);
        musicOsc.start();
        i++;
    }, 280);
}

function stopMusic() {
    if (musicOsc) musicOsc.stop();
    musicOsc = null;
    if (musicInterval) clearInterval(musicInterval);
    musicInterval = null;
}

/* =========================
   RESET
========================= */
function reset() {
    enemies = [];
    roadOffset = 0;
    startTime = performance.now() / 1000;
    lastSpawn = startTime;
    spawnInterval = 2.5;
    player.lane = 1;
    player.x = lanes[1];
    targetX = lanes[1];
    score = 0;
    state = 'playing';
    startMusic();
}

/* =========================
   SOUND FX
========================= */
function playSound(freq, duration) {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = 'square';
    gain.gain.value = 0.2;
    osc.start();
    osc.stop(audioCtx.currentTime + duration / 1000);
}

/* =========================
   SPAWN
========================= */
function spawnObs() {
    let lane;
    do {
        lane = Math.floor(Math.random() * 3);
    } while (lane === player.lane && Math.random() < 0.6);

    enemies.push({
        lane,
        x: lanes[lane],
        y: -carH,
        color: obsColors[Math.floor(Math.random() * obsColors.length)]
    });
}

/* =========================
   UPDATE
========================= */
function update(now) {
    const dt = Math.min(0.05, now - lastTime);
    lastTime = now;

    if (state !== 'playing') {
        if (keys['Space']) reset();
        return;
    }

    const elapsed = now - startTime;
    scrollVel = 180 + elapsed * 0.9;
    roadOffset += scrollVel * dt;
    score += scrollVel * dt * 0.05;

    if (now - lastSpawn > spawnInterval) {
        spawnObs();
        lastSpawn = now;
        spawnInterval = Math.max(0.5, 2.5 - elapsed * 0.0007);
    }

    if (keys['ArrowLeft']) {
        player.lane = Math.max(0, player.lane - 1);
        targetX = lanes[player.lane];
        keys['ArrowLeft'] = false;
    }
    if (keys['ArrowRight']) {
        player.lane = Math.min(2, player.lane + 1);
        targetX = lanes[player.lane];
        keys['ArrowRight'] = false;
    }

    player.x += (targetX - player.x) * 0.22;

    for (let i = enemies.length - 1; i >= 0; i--) {
        const o = enemies[i];
        o.y += (scrollVel + relObsSpeed) * dt;
        o.x += (lanes[o.lane] - o.x) * 0.1;

        if (o.y > canvas.height + 50) {
            enemies.splice(i, 1);
            continue;
        }

        if (Math.abs(player.x - o.x) < carW * 0.6 &&
            Math.abs(player.y - o.y) < carH * 0.6) {

            playSound(150, 400);
            stopMusic();
            state = 'gameover';
            finalScore = Math.floor(score);

            if (finalScore > highScore) {
                highScore = finalScore;
                localStorage.setItem('sodorHS', highScore);
            }
            return;
        }
    }
}

/* =========================
   DRAW HELPERS
========================= */
function drawCar(x, y, color, player=false) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle = color;
    ctx.fillRect(-25, -55, 50, 60);
    ctx.fillStyle = player ? playerDark : '#333';
    ctx.fillRect(-22, -52, 44, 52);
    ctx.fillStyle = '#444';
    ctx.fillRect(-18, -38, 36, 28);
    ctx.fillStyle = '#87CEEB';
    ctx.fillRect(-16, -32, 14, 18);
    ctx.fillRect(2, -32, 14, 18);
    ctx.restore();
}

/* =========================
   BACKGROUND
========================= */
function renderBg() {
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0, 0, roadLeft, canvas.height);
    ctx.fillRect(roadRight, 0, canvas.width - roadRight, canvas.height);

    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(roadLeft, 0, roadRight - roadLeft, canvas.height);

    ctx.strokeStyle = 'white';
    ctx.lineWidth = 5;
    let y = (roadOffset % 60) - 60;
    while (y < canvas.height) {
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, y);
        ctx.lineTo(canvas.width / 2, y + 30);
        ctx.stroke();
        y += 60;
    }
}

/* =========================
   OVERLAY
========================= */
function renderOverlay() {
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.textAlign = 'center';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';

    if (state === 'menu') {
        ctx.font = '48px Arial Black';
        ctx.strokeText('WELCOME TO', canvas.width/2, canvas.height/2 - 120);
        ctx.fillText('WELCOME TO', canvas.width/2, canvas.height/2 - 120);

        ctx.font = '72px Arial Black';
        ctx.strokeText('SODOR ISLAND RACE!', canvas.width/2, canvas.height/2 - 30);
        ctx.fillText('SODOR ISLAND RACE!', canvas.width/2, canvas.height/2 - 30);

        ctx.font = '28px Arial';
        ctx.strokeText('PRESS SPACE OR TAP TO START', canvas.width/2, canvas.height/2 + 80);
        ctx.fillText('PRESS SPACE OR TAP TO START', canvas.width/2, canvas.height/2 + 80);
    }

    if (state === 'gameover') {
        ctx.font = '64px Arial Black';
        ctx.strokeText('GAME OVER', canvas.width/2, canvas.height/2 - 40);
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 40);

        ctx.font = '32px Arial';
        ctx.strokeText(`SCORE: ${finalScore}`, canvas.width/2, canvas.height/2 + 30);
        ctx.fillText(`SCORE: ${finalScore}`, canvas.width/2, canvas.height/2 + 30);

        ctx.strokeText(`HIGH SCORE: ${highScore}`, canvas.width/2, canvas.height/2 + 80);
        ctx.fillText(`HIGH SCORE: ${highScore}`, canvas.width/2, canvas.height/2 + 80);
    }
}

/* =========================
   LOOP
========================= */
function gameLoop() {
    const now = performance.now() / 1000;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    update(now);
    renderBg();

    enemies.forEach(e => drawCar(e.x, e.y, e.color));
    drawCar(player.x, player.y, playerColor, true);

    if (state !== 'playing') renderOverlay();

    requestAnimationFrame(gameLoop);
}

/* =========================
   INPUT
========================= */
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'Space') e.preventDefault();
});
window.addEventListener('keyup', e => keys[e.code] = false);
canvas.addEventListener('touchend', () => reset(), { passive:false });

init();
</script>
</body>
</html>
